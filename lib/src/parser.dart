import 'package:meta/meta.dart';

import 'ast.dart';
import 'exceptions.dart';
import 'scanner.dart';
import 'token.dart';
import 'whitespace_processor.dart';

/// A recursive descent parser for the Silhouette template language.
///
/// Converts a collection of tokens produced by the [Scanner] into an
/// Abstract Syntax Tree (AST) representing the structure of a template.
/// The parser supports complex expressions including:
///
/// - Variable references: `{{ name }}`
/// - Literals: `{{ "hello" }}`, `{{ 42 }}`, `{{ true }}`
/// - Property access: `{{ user.name }}`
/// - Array/map indexing: `{{ items[0] }}`, `{{ data['key'] }}`
/// - Method calls: `{{ text.toUpperCase() }}`
/// - Function calls with arguments: `{{ format('Hello', name: 'World') }}`
/// - Method chaining: `{{ user.getName().toUpperCase() }}`
///
/// The parser follows a recursive descent algorithm,
/// where each grammar rule is implemented as a method that
/// consumes tokens and produces AST nodes.
///
/// Example usage:
/// ```dart
/// final parser = Parser('Hello {{ user.name }}!');
/// final ast = parser.parse();
/// ```
@internal
final class Parser {
  /// The list of tokens to parse.
  ///
  /// Generated by scanning the input template string.
  /// The parser consumes these tokens sequentially to build the AST.
  final List<Token> _tokens;

  /// Current position in the [_tokens] list.
  ///
  /// Points to the token currently being examined.
  /// Advanced as tokens are consumed during parsing.
  int _current = 0;

  /// Creates a parser for the given template [input].
  ///
  /// Automatically scans the input using a [Scanner] to generate
  /// the token stream, then processes it through [WhitespaceProcessor]
  /// to handle whitespace trimming based on `{{-` and `-}}` modifiers.
  /// The input should be a valid Silhouette template string.
  Parser(String input)
    : _tokens = WhitespaceProcessor.process(Scanner(input).scan());

  /// Parses the entire template into a statement tree.
  ///
  /// Returns the root [Statement] node representing the parsed template.
  /// The result depends on the template content:
  ///
  /// - Empty templates return an empty [OrderedStatements]
  /// - Single statements (text or expression) are returned directly
  /// - Multiple statements are wrapped in an [OrderedStatements]
  ///
  /// Throws [ParseException] if the template contains invalid syntax.
  ///
  /// Example results:
  /// ```dart
  /// Parser('Hello').parse();           // TextOutputStatement
  /// Parser('{{ name }}').parse();      // ExpressionOutputStatement
  /// Parser('Hi {{ name }}!').parse();  // OrderedStatements
  /// ```
  @useResult
  Statement parse() {
    final statements = <Statement>[];

    while (!_isAtEnd()) {
      final token = _peek();

      switch (token.type) {
        case TokenType.text:
          statements.add(TextOutputStatement(_advance().value));
        case TokenType.openTag:
          statements.add(_parseTagExpression());
        case TokenType.openComment || TokenType.closeComment:
          // Skip past comment tokens.
          _advance();
        case TokenType.endOfFile:
          break;
        default:
          throw ParseException(
            'Expected text or opening tag, got ${token.type}',
            token: token,
          );
      }
    }

    return switch (statements.length) {
      0 => const OrderedStatements([]),
      1 => statements.first,
      _ => OrderedStatements(statements),
    };
  }

  /// Parses a tag expression in the form `{{ expression }}`.
  ///
  /// Handles both regular expressions and empty tags.
  /// Empty tags (containing only whitespace) produce
  /// empty text output statements for consistency.
  ///
  /// Throws [ParseException] if the tag is malformed or contains
  /// invalid expression syntax.
  @useResult
  Statement _parseTagExpression() {
    _consume(TokenType.openTag, 'Expected opening tag {{');

    // Handle empty tags.
    if (_peek().type == TokenType.closeTag) {
      _advance();
      return const TextOutputStatement(''); // Empty tag produces empty text.
    }

    // Parse the expression.
    final expression = _parseExpression();

    _consume(TokenType.closeTag, 'Expected closing tag }}');

    return ExpressionOutputStatement(expression);
  }

  /// Parses an expression (entry point for expression parsing).
  ///
  /// Currently delegates to [_parsePrimary], but provides a clear
  /// entry point for future expansion when operator precedence
  /// and additional expression types are added.
  @useResult
  Expression _parseExpression() => _parsePrimary();

  /// Parses a primary expression and any postfix operations.
  ///
  /// This method handles the core expression parsing with left-to-right
  /// associativity for postfix operations. It starts with a base primary
  /// expression and then chains any number of:
  ///
  /// - Property access: `.property`
  /// - Index access: `[index]`
  /// - Function calls: `(arguments)`
  ///
  /// This allows for complex chaining like:
  /// `user.getAddress().street.toUpperCase().substring(0, end: 10)`
  @useResult
  Expression _parsePrimary() {
    var expr = _parsePrimaryBase();

    // Handle postfix operations.
    while (true) {
      final token = _peek();

      switch (token.type) {
        case TokenType.dot:
          expr = _parsePropertyAccess(expr);
        case TokenType.openSquareBracket:
          expr = _parseIndexAccess(expr);
        case TokenType.openParenthesis:
          expr = _parseFunctionCall(expr);
        default:
          return expr;
      }
    }
  }

  /// Parses the base primary expression, such as
  /// literals, identifiers, and grouped expressions.
  ///
  /// This method handles the atomic expression types that
  /// can't be further decomposed:
  ///
  /// - Identifiers: `name`, `user`
  /// - String literals: `"hello"`, `'world'`
  /// - Number literals: `42`, `3.14`
  /// - Boolean literals: `true`, `false`
  /// - Null literal: `null`
  /// - Grouped expressions: `(expression)`
  ///
  /// Throws [ParseException] for unexpected tokens.
  @useResult
  Expression _parsePrimaryBase() {
    final token = _peek();

    return switch (token.type) {
      TokenType.identifier => IdentifierExpression(_advance()),
      TokenType.stringLiteral => _parseStringLiteral(),
      TokenType.numberLiteral => _parseNumberLiteral(),
      TokenType.trueKeyword => _parseBooleanLiteral(true),
      TokenType.falseKeyword => _parseBooleanLiteral(false),
      TokenType.nullKeyword => _parseNullLiteral(),
      TokenType.openParenthesis => _parseGroupedExpression(),
      _ => throw ParseException(
        'Unexpected token in expression: ${token.type}',
        token: token,
      ),
    };
  }

  /// Parses a string literal expression.
  ///
  /// Creates a [LiteralExpression] with the string value from the token.
  /// The scanner handles escape sequence processing, so the token value
  /// is already the final string content.
  @useResult
  Expression _parseStringLiteral() {
    final token = _advance();
    return LiteralExpression(token, value: token.value);
  }

  /// Parses a number literal expression.
  ///
  /// Creates a [LiteralExpression] with either an [int] or [double] value
  /// depending on whether the number contains a decimal point.
  /// Uses the [_parseNumber] helper to convert the string to
  /// the appropriate numeric type.
  @useResult
  Expression _parseNumberLiteral() {
    final token = _advance();
    final value = _parseNumber(token.value);
    return LiteralExpression(token, value: value);
  }

  /// Parses a boolean literal expression.
  ///
  /// Creates a [LiteralExpression] with the given boolean [value].
  /// The token is consumed but the actual boolean value is provided
  /// by the caller based on whether this was `true` or `false`.
  Expression _parseBooleanLiteral(bool value) {
    final token = _advance();
    return LiteralExpression(token, value: value);
  }

  /// Parses a null literal expression.
  ///
  /// Creates a [LiteralExpression] with a `null` value.
  Expression _parseNullLiteral() {
    final token = _advance();
    return LiteralExpression(token, value: null);
  }

  /// Parses a grouped expression in parentheses.
  ///
  /// Handles expressions wrapped in parentheses for precedence control
  /// or clarity. The parentheses are consumed but don't affect the
  /// resulting AST structure - only the inner expression is returned.
  ///
  /// Example: `(user.name)` produces the same AST as `user.name`.
  Expression _parseGroupedExpression() {
    // Consume opening parenthesis.
    _advance();

    final expr = _parseExpression();
    _consume(TokenType.closeParenthesis, 'Expected ) after expression');
    return expr;
  }

  /// Parses property access in the form `expression.property`.
  ///
  /// Creates a [PropertyAccessExpression] that accesses a property
  /// or method of the given [object] expression.
  /// The property name must be a valid identifier.
  ///
  /// Example: `user.name` where `user` is the object and `name` is
  /// the property being accessed.
  @useResult
  Expression _parsePropertyAccess(Expression object) {
    final dotToken = _consume(TokenType.dot, 'Expected .');
    final identifier = _consume(
      TokenType.identifier,
      'Expected identifier after .',
    );

    return PropertyAccessExpression(object, dotToken, identifier);
  }

  /// Parses index access in the form `expression[index]`.
  ///
  /// Creates an [IndexAccessExpression] that accesses an element
  /// by index or key. The index can be any valid expression.
  ///
  /// Examples:
  /// - `items[0]` - Array access with integer index
  /// - `data['key']` - Map access with string key
  /// - `matrix[i][j]` - Nested array access
  @useResult
  Expression _parseIndexAccess(Expression object) {
    final leftBracket = _consume(TokenType.openSquareBracket, 'Expected [');
    final index = _parseExpression();
    final rightBracket = _consume(
      TokenType.closeSquareBracket,
      'Expected ] after index expression',
    );

    return IndexAccessExpression(object, leftBracket, index, rightBracket);
  }

  /// Parses function call in the form `expression(arguments)`.
  ///
  /// Creates a [CallExpression] with support for both positional and
  /// named arguments in flexible order.
  /// Arguments are parsed according to these rules:
  ///
  /// - Positional arguments can appear anywhere in the argument list
  /// - Named arguments use the syntax `name: value`
  /// - Arguments are separated by commas
  /// - Empty argument lists are allowed: `function()`
  ///
  /// Examples:
  /// - `func(a, b, c)` - All positional arguments
  /// - `func(name: "John", age: 30)` - All named arguments
  /// - `func(a, name: "John", b)` - Mixed positional and named
  ///
  /// Throws [ParseException] for duplicate named parameters or
  /// malformed argument syntax.
  @useResult
  Expression _parseFunctionCall(Expression callee) {
    final leftParen = _consume(TokenType.openParenthesis, 'Expected (');

    final positionalArguments = <Expression>[];
    final namedArguments = <String, Expression>{};

    // Parse arguments if any.
    if (_peek().type != TokenType.closeParenthesis) {
      _parseArgument(positionalArguments, namedArguments);
      while (_match(TokenType.comma)) {
        _parseArgument(positionalArguments, namedArguments);
      }
    }

    final rightParen = _consume(
      TokenType.closeParenthesis,
      'Expected ) after arguments',
    );

    return CallExpression(
      callee,
      leftParen,
      positionalArguments,
      namedArguments,
      rightParen,
    );
  }

  /// Parses a single argument (either positional or named).
  ///
  /// Determines whether the current argument is named (has the pattern
  /// `identifier : expression`) or positional, then delegates to the
  /// appropriate parsing method.
  ///
  /// Named arguments are detected by looking ahead for a colon after
  /// an identifier token.
  void _parseArgument(
    List<Expression> positionalArguments,
    Map<String, Expression> namedArguments,
  ) {
    // Check if this looks like a named argument (identifier : expression).
    if (_peek().type == TokenType.identifier && _isNamedArgument()) {
      _parseNamedArgument(namedArguments);
    } else {
      // This is a positional argument.
      positionalArguments.add(_parseExpression());
    }
  }

  /// Checks if the current position represents a named argument pattern.
  ///
  /// Uses single-token lookahead to detect the `identifier : expression`
  /// pattern without consuming tokens. This allows the parser to decide
  /// between named and positional arguments.
  @useResult
  bool _isNamedArgument() => _peekAt(1).type == TokenType.colon;

  /// Parses a named argument in the form `name: expression`.
  ///
  /// Extracts the parameter name from the identifier token and
  /// parses the associated expression value. Validates that parameter
  /// names are not duplicated within the same function call.
  ///
  /// Throws [ParseException] for duplicate parameter names.
  void _parseNamedArgument(Map<String, Expression> namedArguments) {
    final nameToken = _consume(TokenType.identifier, 'Expected parameter name');
    _consume(TokenType.colon, 'Expected : after parameter name');
    final value = _parseExpression();

    final paramName = nameToken.value;
    if (namedArguments.containsKey(paramName)) {
      throw ParseException(
        'Duplicate named parameter: $paramName',
        token: nameToken,
      );
    }
    namedArguments[paramName] = value;
  }

  /// Parses a number from its string representation.
  ///
  /// Returns an [int] for whole numbers without decimal points,
  /// or a [double] for numbers containing decimal points.
  ///
  /// Examples:
  /// - `"42"` → `42` (int)
  /// - `"3.14"` → `3.14` (double)
  /// - `"0"` → `0` (int)
  ///
  /// Throws a [FormatException] if the string is not a valid number.
  @useResult
  num _parseNumber(String value) =>
      value.contains('.') ? double.parse(value) : int.parse(value);

  /// Checks if the current token matches the given [type] and advances if so.
  ///
  /// This is a utility method for optional token matching.
  /// Returns `true` and consumes the token if it matches, or
  /// returns `false` and leaves the token unconsumed if it doesn't match.
  ///
  /// Commonly used for parsing optional elements like trailing commas.
  @useResult
  bool _match(TokenType type) {
    if (_peek().type == type) {
      _advance();
      return true;
    }
    return false;
  }

  /// Consumes a token of the expected [type] or throws a parse error.
  ///
  /// This is the primary method for mandatory token consumption.
  /// It validates that the current token matches
  /// the expected type and advances past it.
  /// If the token doesn't match,
  /// throws a [ParseException] with the provided error message.
  ///
  /// Returns the consumed token for cases where its value is needed.
  ///
  /// Example:
  /// ```dart
  /// final openParen = _consume(TokenType.openParenthesis, 'Expected (');
  /// ```
  Token _consume(TokenType type, String message) {
    final token = _peek();
    if (token.type == type) {
      return _advance();
    }
    throw ParseException(message, token: token);
  }

  /// Advances to the next token and returns the previous one.
  ///
  /// This is the primary method for consuming tokens during parsing.
  /// It moves the current position forward and returns the token that
  /// was just consumed. If already at the end of the token stream,
  /// the position doesn't advance further.
  Token _advance() {
    if (!_isAtEnd()) {
      _current++;
    }
    return _previous();
  }

  /// Checks if we're at the end of the token stream.
  ///
  /// Returns `true` when the current token is the end-of-file marker,
  /// indicating that there are no more tokens to process.
  @useResult
  bool _isAtEnd() => _peek().type == TokenType.endOfFile;

  /// Peeks at the current token without advancing.
  ///
  /// Returns the token at the current position for inspection
  /// without consuming it. This is safe to call even at the end
  /// of the token stream (returns the end-of-file token).
  @useResult
  Token _peek() => _tokens[_current];

  /// Peeks at the token at the given [offset] from the current position.
  @useResult
  Token _peekAt(int offset) {
    final index = _current + offset;
    if (index >= _tokens.length) {
      return _tokens.last;
    }
    return _tokens[index];
  }

  /// Returns the previous token.
  ///
  /// Returns the token that was most recently consumed. If at the
  /// beginning of the token stream, returns the first token.
  /// Used primarily by [_advance] to return the consumed token.
  @useResult
  Token _previous() => _tokens[_current > 0 ? _current - 1 : 0];
}
